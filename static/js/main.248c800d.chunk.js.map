{"version":3,"sources":["store/webgl/types.ts","store/webgl/reducers.ts","store/projections/types.ts","store/projections/reducers.ts","store/radon/actions.ts","store/radon/reducers.ts","store/reducer.ts","components/radon/scene.tsx","containers/radon.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["WebGLActionType","MutationActionType","initialState","context","undefined","payloadSetter","t","state","action","type","payload","anchor","SET_ANCHOR","originalRotation","SET_ORIGINAL_ROTATION","rotationDelta","SET_ROTATION_DELTA","combineReducers","rotation","ROTATE","MODIFY_ROTATION","add","valueOf","translation","TRANSLATE","scale","SCALE","MODIFY_SCALE","boxUpdate","x","updateBox","updateBeamBox","initialBoxState","matrix","initialBeamBoxState","radon","beamBox","box","rays","inverted","recording","opacities","Array","BB_WIDTH","out","of","unshift","pop","reducer","webgl","SET_CONTEXT","projections","v","y","z","Vector3","getRow","m","row","subset","index","toArray","BoxMesh","color","w","h","d","a","b","c","geometry","BoxGeometry","translate","rotateX","rotateY","rotateZ","Mesh","co","Color","MeshPhongMaterial","specular","addScalar","emissive","shininess","wireframe","side","DoubleSide","meshColor","Beams","bbox","material","geo","PlaneGeometry","mat","MeshBasicMaterial","transparent","opacity","map","RadonScene","children","webGLRenderer","camera","scene","this","WebGLRenderer","setSize","window","innerWidth","innerHeight","setPixelRatio","devicePixelRatio","Scene","PerspectiveCamera","position","light","DirectionalLight","set","normalize","OrbitControls","domElement","forEach","render","id","ref","appendChild","InvButton","props","style","padding","backgroundColor","fontSize","borderRadius","onClick","invert","Radon","rs","bb","screen","tl","beamData","TextureLoader","Math","PI","theta","requestAnimationFrame","rotateBox","rayCount","pow","floor","numRays","beams","obj","N","opts","canvas","document","createElement","height","width","getContext","imgData","createImageData","ops","i","by","start","end","srcPos","destPos","intersections","Raycaster","sub","intersectObject","inv","attStart","att","length","distance","defVal","j","data","push","saveOpacity","putImageData","toDataURL","getBeamDataUrl","load","screenData","col","pxl","getScreenDataUrl","maxRayCount","ceil","log2","display","flexDirection","alignItems","min","max","value","onChange","e","setRayCount","parseInt","target","invertBeams","Component","connect","dispatch","rotateBeamBox","n","o","toggleRecording","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","store","createStore","applyMiddleware","thunk","App","Boolean","location","hostname","match","ReactDOM","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.248c800d.chunk.js","sourcesContent":["export type Mat4 = [\n    number, number, number, number,\n    number, number, number, number,\n    number, number, number, number,\n    number, number, number, number,\n];\n\nexport interface WebGLState {\n    context: WebGLRenderingContext | undefined;\n}\n\nexport enum WebGLActionType {\n    SET_CONTEXT = 'SET_CONTEXT'\n}\n\nexport interface SetWebGLContextAction {\n    type: WebGLActionType;\n    payload: WebGLRenderingContext;\n}\n\nexport type WebGLAction = SetWebGLContextAction","import {WebGLState, WebGLAction, WebGLActionType} from 'store/webgl/types'\n\nvar initialState: WebGLState = {\n    context: undefined,\n};\n\nexport default function reducer(\n    state = initialState,\n    action: WebGLAction\n): WebGLState {\n    if (action === undefined ) {\n        return state;\n    }\n\n    switch(action.type) {\n        case WebGLActionType.SET_CONTEXT:\n            return {context: action.payload};\n        default:\n            return state;\n    }\n}","import {Vec3} from 'store/types';\nexport interface MutationState {\n  rotation: Vec3;\n  translation: Vec3;\n  scale: Vec3;\n  rotationDelta: Vec3 | null;\n  originalRotation: Vec3 | null;\n  anchor: Vec3 | null;\n}\n\nexport enum MutationActionType {\n  ROTATE = 'ROTATE',\n  TRANSLATE = 'TRANSLATE',\n  SCALE = 'SCALE',\n  MODIFY_SCALE = 'MODIFY_SCALE',\n  MODIFY_ROTATION = 'MODIFY_ROTATION',\n  SET_ANCHOR = 'SET_ANCHOR',\n  SET_ORIGINAL_ROTATION = 'SET_ORIGINAL_ROTATION',\n  SET_ROTATION_DELTA = 'SET_ROTATION_DELTA',\n  CALC_ROT = 'CALC_ROT',\n}\n\nexport interface MutationAction {\n  type: MutationActionType;\n  payload: Vec3 | null;\n}\n","import {\n  MutationState,\n  MutationAction,\n  MutationActionType,\n} from 'store/projections/types';\nimport {Vec3} from 'store/types';\nimport {add} from 'mathjs';\nimport {combineReducers} from 'redux';\n\nfunction payloadSetter(t: MutationActionType) {\n  return function(state: Vec3 | undefined | null, action: MutationAction) {\n    if (state === undefined) return null;\n    if (action.type !== t) return state;\n    return action.payload;\n  };\n}\n\nconst anchor = payloadSetter(MutationActionType.SET_ANCHOR);\nconst originalRotation = payloadSetter(\n  MutationActionType.SET_ORIGINAL_ROTATION,\n);\nconst rotationDelta = payloadSetter(MutationActionType.SET_ROTATION_DELTA);\n\nfunction translation(\n  translation: Vec3 = [0, 0, 0],\n  action: MutationAction,\n): Vec3 {\n  if (action.type !== MutationActionType.TRANSLATE) return translation;\n\n  if (action.payload === null) return translation;\n\n  return action.payload;\n}\n\nfunction scale(scale: Vec3 = [1, 1, 1], action: MutationAction) {\n  if (!action.payload) return scale;\n\n  switch (action.type) {\n    case MutationActionType.SCALE:\n      return action.payload;\n    case MutationActionType.MODIFY_SCALE:\n      return add(scale, action.payload).valueOf() as Vec3;\n    default:\n      return scale;\n  }\n}\n\nfunction rotation(rotation: Vec3 = [0, 0, 0], action: MutationAction) {\n  if (!action.payload) return rotation;\n\n  switch (action.type) {\n    case MutationActionType.ROTATE:\n      return action.payload;\n    case MutationActionType.MODIFY_ROTATION:\n      return add(rotation, action.payload).valueOf() as Vec3;\n    default:\n      return rotation;\n  }\n}\n\nexport default combineReducers<MutationState, MutationAction>({\n  rotation,\n  translation,\n  scale,\n  anchor,\n  originalRotation,\n  rotationDelta,\n});\n","import {Matrix} from 'mathjs';\n\n// action types\n\nexport const UPDATE_BOX = 'UPDATE_BOX';\nexport const UPDATE_BEAM_BOX = 'UPDATE_BEAM_BOX';\nexport const SET_RAY_COUNT = 'SET_RAY_COUNT';\nexport const INVERT_BEAMS = 'INVERT_BEAMS';\nexport const TOGGLE_RECORDING = 'TOGGLE_RECORDING';\nexport const SAVE_OPACITY = 'SAVE_OPACITY';\n\n// action shapes\n\nexport interface rayAction {\n  type: typeof SET_RAY_COUNT;\n  payload: number;\n}\n\nexport interface boxAction {\n  type: typeof UPDATE_BOX | typeof UPDATE_BEAM_BOX;\n  payload: Matrix;\n}\n\nexport interface invertBeamsAction {\n  type: typeof INVERT_BEAMS;\n}\n\nexport interface toggleRecordingAction {\n  type: typeof TOGGLE_RECORDING;\n}\n\nexport interface saveOpacityAction {\n  type: typeof SAVE_OPACITY;\n  payload: number[];\n}\n\nexport type RadonAction =\n  | boxAction\n  | rayAction\n  | invertBeamsAction\n  | toggleRecordingAction\n  | saveOpacityAction;\n\nconst boxUpdate = (t: typeof UPDATE_BOX | typeof UPDATE_BEAM_BOX) => (\n  x: Matrix,\n) => ({\n  type: t,\n  payload: x,\n});\n\n// action creators\n\nexport const updateBox = boxUpdate(UPDATE_BOX);\nexport const updateBeamBox = boxUpdate(UPDATE_BEAM_BOX);\n\nexport const setRayCount = (n: number): rayAction => ({\n  type: SET_RAY_COUNT,\n  payload: n,\n});\n\nexport const invertBeams = (): invertBeamsAction => ({type: INVERT_BEAMS});\n\nexport const saveOpacity = (payload: number[]): saveOpacityAction => ({\n  type: SAVE_OPACITY,\n  payload,\n});\n\nexport const toggleRecording = (): toggleRecordingAction => ({\n  type: TOGGLE_RECORDING,\n});\n","import {add, Matrix, matrix} from 'mathjs';\nimport {combineReducers} from 'redux';\nimport {\n  boxAction,\n  rayAction,\n  invertBeamsAction,\n  toggleRecordingAction,\n  saveOpacityAction,\n  UPDATE_BOX,\n  UPDATE_BEAM_BOX,\n  SET_RAY_COUNT,\n  INVERT_BEAMS,\n  TOGGLE_RECORDING,\n  SAVE_OPACITY,\n} from 'store/radon/actions';\n\nconst initialBoxState = matrix([[0, 0, 0], [32, 16, 8], [0, 0, 0]]);\n\nconst box = (state: Matrix | undefined, action: boxAction) => {\n  if (state === undefined) return initialBoxState;\n  return action.type === UPDATE_BOX\n    ? (add(action.payload, state) as Matrix)\n    : state;\n};\n\nconst rays = (state: number | undefined, action: rayAction) => {\n  if (state === undefined) return 0;\n  return action.type === SET_RAY_COUNT ? action.payload : state;\n};\n\nconst BB_WIDTH = 64;\nconst BB_HEIGHT = 64;\nconst initialBeamBoxState = matrix([\n  [0, 0, 0],\n  [BB_WIDTH, BB_HEIGHT, 4],\n  [0, 0, 0],\n]);\n\nconst beamBox = (state: Matrix | undefined, action: boxAction) => {\n  if (state === undefined) return initialBeamBoxState;\n  return action.type === UPDATE_BEAM_BOX\n    ? (add(action.payload, state) as Matrix)\n    : state;\n};\n\nconst inverted = (state: boolean | undefined, action: invertBeamsAction) => {\n  return action.type === INVERT_BEAMS ? !state : !!state;\n};\n\nconst recording = (\n  state: boolean | undefined,\n  action: toggleRecordingAction,\n) => {\n  if (state === undefined) return true;\n\n  return action.type === TOGGLE_RECORDING ? !state : state;\n};\n\nconst opacities = (\n  state: number[][] | undefined,\n  action: saveOpacityAction,\n) => {\n  // here we use * 4 b/c that's how many rotation values we want to capture\n  if (state === undefined) return Array(BB_WIDTH * 4);\n\n  if (action.type === SAVE_OPACITY) {\n    let out = Array.of(...state);\n    out.unshift(action.payload);\n    out.pop();\n    return out;\n  }\n\n  return state;\n};\n\nconst radon = combineReducers({\n  beamBox,\n  box,\n  rays,\n  inverted,\n  recording,\n  opacities,\n});\n\nexport default radon;\nexport type radonState = ReturnType<typeof radon>;\n","import webgl from 'store/webgl/reducers';\nimport {WebGLAction} from 'store/webgl/types';\nimport projections from 'store/projections/reducers';\nimport radon from 'store/radon/reducers';\nimport {RadonAction} from 'store/radon/actions';\nimport {MutationAction} from 'store/projections/types';\nimport {combineReducers} from 'redux';\n\nconst reducer = combineReducers({\n  webgl,\n  projections,\n  radon,\n});\n\nexport type ReduxState = ReturnType<typeof reducer>;\nexport type ReduxAction = WebGLAction | MutationAction | RadonAction;\nexport default reducer;\n","import React, {Component} from 'react';\nimport {Matrix, matrix, index} from 'mathjs';\n\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport {\n    Object3D,\n    Vector3,\n    Color,\n    MeshPhongMaterial,\n    DoubleSide,\n    BoxGeometry,\n    Mesh,\n    WebGLRenderer,\n    Camera,\n    Scene,\n    PerspectiveCamera,\n    DirectionalLight,\n    Raycaster,\n    TextureLoader,\n    Texture,\n    MeshBasicMaterial,\n    PlaneGeometry,\n    Material,\n} from 'three';\n\n\nconst v = (x: number, y: number, z: number) => new Vector3(x, y, z)\n\n function meshColor(color: number) {\n     const co = () => new Color(color)\n     return new MeshPhongMaterial({\n         // light\n         specular: co(),\n         // intermediate\n         color: co().addScalar(-.3),\n         // dark\n         emissive: co().addScalar(-.8),\n         shininess: 50,\n         wireframe: false,\n         side: DoubleSide,\n         //map: ImageUtils.loadTexture('http://i.imgur.com/xCE2Br4.jpg?1')\n     });\n }\n\nfunction getRow(m: Matrix, row: number): number[] {\n    return (m.subset(index(row, [0, 1, 2])).toArray() as number[][])[0]\n}\n\nfunction BoxMesh(box: Matrix, color?: number) {\n    const [x, y, z] = getRow(box, 0)\n    const [w, h, d] = getRow(box, 1)\n    const [a, b, c] = getRow(box, 2)\n\n    var geometry = new BoxGeometry(w, h, d)\n\n    geometry.translate(x, y, z)\n    geometry.rotateX(a)\n    geometry.rotateY(b)\n    geometry.rotateZ(c)\n\n    return new Mesh(geometry, meshColor(color || 0xffffff))\n }\n\n\ninterface beamDataOpts {\n    inv: boolean;\n    recording: boolean;\n    saveOpacity: (o: number[]) => void;\n}\n\nfunction getScreenDataUrl(bbox: Matrix, opacities: number[][]): string {\n    let [w, h] = getRow(bbox, 1)\n    // here we use * 4 b/c that's how many rotation values we want to capture\n    w = w * 4\n\n    /* // Create canvas */\n    let canvas = document.createElement('canvas');\n    canvas.height = h;\n    canvas.width = w;\n\n    const context = canvas.getContext('2d');\n    if( context === null ) return '';\n    const imgData = context.createImageData(w, h);\n\n    // the number of stored opacities should equal the width of the bounding box\n    for( let col = 0; col < opacities.length; col++ ) {\n        let N = opacities[col] ? opacities[col].length : 0\n        for( let i = 0; i < N; i++ ) {\n            const row = Math.floor(i*(h/N)+h/(2*N))\n            // row * w * 4 + col * 4\n            // 4 * (row * w + col)\n            let pxl = 4 * (row * w + col)\n            imgData.data[pxl] = 255\n            imgData.data[pxl + 1] = 255\n            imgData.data[pxl + 2] = 255\n            imgData.data[pxl + 3] = opacities[col][i]\n        }\n    }\n\n    context.putImageData(imgData, 0, 0)\n    return canvas.toDataURL()\n}\n\nfunction getBeamDataUrl(obj: Object3D, bbox: Matrix, N: number, opts: beamDataOpts): string {\n    const [x, y, z] = getRow(bbox, 0)\n    const [w, h] = getRow(bbox, 1)\n\n    /* // Create canvas */\n    let canvas = document.createElement('canvas');\n    canvas.height = h;\n    canvas.width = w;\n\n    const context = canvas.getContext('2d');\n    if( context === null ) return '';\n    const imgData = context.createImageData(w, h);\n\n    let ops = []\n\n    for( let i = 0; i < N; i++) {\n        const by = Math.floor(y+(i*(h/N))+h/(2*N))\n\n        const start = by * w * 4\n        const end = start + w * 4\n\n        // apparently box geometries are centered at the origin\n        // hence the x +- w/2 for the ray start and end\n        const srcPos = v(x-w/2, (h/2)-by, z)\n        const destPos =  v(x + w/2, (h/2)-by, z)\n\n        const ray = new Raycaster(srcPos, destPos.sub(srcPos).normalize())\n        const intersections = ray.intersectObject(obj)\n\n        let opacity = opts.inv ? 0 : 255\n        let attStart = end\n        let dist = 0\n        let att = 0\n        switch( intersections.length ) {\n            case 2:\n                dist = intersections[1].distance - intersections[0].distance\n                att = dist/40\n                opacity = opts.inv ? att*255 : (1-att)*255\n                attStart = intersections[1].distance\n                break;\n            case 4:\n                dist = intersections[2].distance - intersections[1].distance\n                att = dist/40\n                opacity = opts.inv ? att*255 : (1-att)*255\n                attStart = intersections[2].distance\n                break;\n        }\n\n        const defVal = opts.inv ? 0 : 255\n\n        for (let j = start; j < end; j+=4) {\n            imgData.data[j] = 255\n            imgData.data[j+1] = 255\n            imgData.data[j+2] = 255\n            imgData.data[j+3] = (j-start)/4 >= attStart-2 ? opacity : defVal\n        }\n\n        ops.push(opacity)\n    }\n\n    if ( opts.recording ) opts.saveOpacity(ops) \n\n    // put data to context at (0, 0)\n    context.putImageData(imgData, 0, 0);\n\n    return canvas.toDataURL()\n}\n\nconst Beams = (bbox: Matrix, material?: Material) => {\n    const [x, y, z] = getRow(bbox, 0)\n    const [w, h] = getRow(bbox, 1)\n    const [a, b, c] = getRow(bbox, 2)\n    const geo = new PlaneGeometry(w, h)\n    geo.rotateX(a)\n    geo.rotateY(b)\n    geo.rotateZ(c)\n    geo.translate(x, y, z)\n\n    const mat = new MeshBasicMaterial( {transparent: true, opacity: 0, map: null} );\n    return new Mesh(geo, material || mat)\n}\n\nclass RadonScene {\n    webGLRenderer: WebGLRenderer\n    camera: Camera\n    scene: Scene\n\n    constructor(children: Array<Object3D | Mesh>) {\n        this.webGLRenderer = new WebGLRenderer()\n        this.webGLRenderer.setSize( window.innerWidth, window.innerHeight )\n        this.webGLRenderer.setPixelRatio( window.devicePixelRatio );\n\n        this.scene = new Scene()\n\n        this.camera = new PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 0.1, 1000 )\n        this.camera.position.x = 0\n        this.camera.position.y = 20\n        this.camera.position.z = 150\n\n        var light = new DirectionalLight(0xfdfdfd, 2);\n        // you set the position of the light and it shines into the origin\n        light.position.set(-2, 2, 1).normalize();\n        this.scene.add(light);\n        new OrbitControls(this.camera, this.webGLRenderer.domElement)\n\n        children.forEach(c => this.scene.add(c as Object3D));\n    }\n\n    render() {\n        this.webGLRenderer.render(this.scene, this.camera)\n        return (<div id=\"scene-container\" ref={d => d ? d.appendChild(this.webGLRenderer.domElement) : \"\"}></div>)\n    }\n}\n\n\ninterface InvButtonProps {\n    inverted: boolean;\n    invert: () => void\n}\n\nconst InvButton: React.FC<InvButtonProps> = (props: InvButtonProps) => (\n    <div style={{padding: '16px'}}>\n        <button style={{\n            color: props.inverted ? 'white' : 'black',\n            backgroundColor: props.inverted ? 'black' : 'white',\n            fontSize: '16px',\n            borderRadius: '8px',\n        }}\n            onClick={props.invert}>\n            Invert\n        </button>\n    </div>)\n\ninterface RadonProps {\n    box: Matrix;\n    beamBox: Matrix;\n    numRays: number;\n    inverted: boolean;\n    recording: boolean;\n    opacities: number[][];\n    rotateBox: (n: number) => void;\n    setRayCount: (n: number) => void;\n    invertBeams: () => void;\n    saveOpacity: (o: number[]) => void;\n    toggleRecording: () => void;\n}\n\nexport default class Radon extends Component<RadonProps> {\n    rs: RadonScene\n    b: Object3D\n    bb: Object3D\n    screen: Object3D\n    tl: TextureLoader\n    beamData: string\n\n    constructor(props: RadonProps) {\n        super(props)\n\n        this.beamData = ''\n        this.tl = new TextureLoader()\n        this.b = BoxMesh(this.props.box, 0x0000ff)\n        this.bb = Beams(this.props.beamBox)\n\n        const [x, y, z] = getRow(this.props.beamBox, 0)\n        const [w, h, d] = getRow(this.props.beamBox, 1)\n\n        this.screen = Beams(matrix([[x+w/2, y, z+w/2],[w,h,d],[0,-Math.PI/2,0]]))\n        this.rs = new RadonScene([\n            this.b,\n            this.bb,\n            this.screen,\n        ])\n\n        // here we use * 4 b/c that's how many rotation values we want to capture\n        const theta = Math.PI/(w*4)\n\n        const rotateBox = () => {\n            this.b.rotateZ(theta)\n            this.props.rotateBox(theta)\n\n            const rayCount = Math.pow(2, Math.floor(this.props.numRays))\n\n            const beams = this.bb as Mesh\n            const beamData = getBeamDataUrl(this.b, this.props.beamBox, rayCount, {\n                inv: this.props.inverted,\n                recording: this.props.recording,\n                saveOpacity: this.props.saveOpacity,\n            })\n\n            // only create new beam image if beams have been updated\n            if( beamData && beamData !== this.beamData ) {\n                this.tl.load(beamData, (t: Texture) => {\n                    beams.material = new MeshBasicMaterial({map: t, transparent: true})\n                })\n                this.beamData = beamData\n            }\n\n            if( this.props.recording ) {\n                const screen = this.screen as Mesh\n                const screenData = getScreenDataUrl(this.props.beamBox, this.props.opacities)\n\n                this.tl.load(screenData, (t: Texture) => {\n                    screen.material = new MeshBasicMaterial({map: t, transparent: true})\n                })\n            }\n\n            requestAnimationFrame(rotateBox)\n        }\n\n        requestAnimationFrame(rotateBox)\n    }\n\n    render() {\n        /* this.bb.rotateZ(.01) */\n        const h = getRow(this.props.beamBox, 1)[1]\n        const maxRayCount = Math.ceil(Math.log2(h))\n        const rayCount = Math.pow(2, Math.floor(this.props.numRays))\n\n        return (\n            <div>\n                <div id='controls' style={{position: 'absolute', display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '16px'}}>\n                    <h1 style={{color: 'white'}} >{rayCount} Beam{rayCount > 1 ? 's' : ''}</h1>\n                    <input type='range' min={0} max={maxRayCount} value={this.props.numRays} onChange={e => this.props.setRayCount(parseInt(e.target.value))} />\n                    <InvButton invert={this.props.invertBeams} inverted={this.props.inverted} />\n                </div>\n                {this.rs.render()}\n            </div>)\n    }\n}\n","import {connect} from 'react-redux';\nimport {matrix} from 'mathjs';\nimport {ReduxState} from 'store/reducer';\nimport {\n  updateBox,\n  updateBeamBox,\n  setRayCount,\n  RadonAction,\n  invertBeams,\n  saveOpacity,\n  toggleRecording,\n} from 'store/radon/actions';\nimport RadonScene from 'components/radon/scene';\n\nconst rotateZ = (theta: number) =>\n  matrix([[0, 0, 0], [0, 0, 0], [0, 0, theta]]);\n\nconst mapState = (state: ReduxState) => ({\n  box: state.radon.box,\n  beamBox: state.radon.beamBox,\n  numRays: state.radon.rays,\n  inverted: state.radon.inverted,\n  recording: state.radon.recording,\n  opacities: state.radon.opacities,\n});\n\nconst mapDispatch = (dispatch: (action: RadonAction) => void) => ({\n  rotateBox: (theta: number) => dispatch(updateBox(rotateZ(theta))),\n  rotateBeamBox: (theta: number) => dispatch(updateBeamBox(rotateZ(theta))),\n  setRayCount: (n: number) => dispatch(setRayCount(n)),\n  invertBeams: () => dispatch(invertBeams()),\n  saveOpacity: (o: number[]) => dispatch(saveOpacity(o)),\n  toggleRecording: () => dispatch(toggleRecording()),\n});\n\nexport default connect(\n  mapState,\n  mapDispatch,\n)(RadonScene);\n","import React from 'react';\nimport './App.css';\nimport reducer from 'store/reducer';\nimport {createStore, applyMiddleware, compose} from 'redux';\nimport {Provider} from 'react-redux';\nimport thunk from 'redux-thunk'\nimport RadonScene from 'containers/radon';\n// import ConfigPanel from 'containers/mutations/config-panel';\n// import ShaderCanvas from 'containers/canvas/shader-canvas'\n\nconst composeEnhancers = (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\nconst store = createStore(reducer, composeEnhancers(\n  applyMiddleware(thunk),\n))\n\n/* <ConfigPanel />\n<ShaderCanvas /> */\n\nconst App: React.FC = () => {\n  return (\n    <Provider store={store}>\n      <RadonScene />\n    </Provider>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}